; Generated by JITX 3.25.0
#use-added-syntax(jitx)
defpackage main :
  import core
  import jitx
  import jitx/commands
  import jitx/parts

  import jsl
  import jsl/bundles

  ; import jsl/protocols/usb
  import jsl/si/constraints
  import jsl/si/pairs
  import jsl/si/helpers
  import jsl/si/couplers
  import jsl/symbols/net-symbols

  import ASM001/board
  import ASM001/helpers
  import ASM001/common/components


; Define the shape/size of the board
val board-shape = RoundedRectangle(100.0, 100.0, 0.25)
val VBUS-shape = RoundedRectangle(100.0, 100.0, 0.25)
val P3V3-shape = RoundedRectangle(100.0, 100.0, 0.25)
val P1V8-shape = RoundedRectangle(100.0, 100.0, 0.25)
val P1V05-shape = RoundedRectangle(100.0, 100.0, 0.25)

; Module to run as a design
pcb-module ASM001-design :

  val R-query = get-default-resistor-query()
  val C-query = get-default-capacitor-query()
  
  ;;;;; main power circuits
  inst power-circuit : ASM001/module/power/circuit
  place(power-circuit) at loc(-30.0, 35.0) on Top

  net VBUS (power-circuit.vbus.V+)
  net GND (power-circuit.vbus.V- power-circuit.rail-3v3.V- power-circuit.rail-1v8.V- power-circuit.rail-1v05.V-)

  net P3V3 (power-circuit.rail-3v3.V+)
  net P1V8 (power-circuit.rail-1v8.V+)
  net P1V05 (power-circuit.rail-1v05.V+)




  geom(VBUS) :
    copper-pour(LayerIndex(2, Top), isolate = 0.127, rank = 1) =  board-shape
  geom(GND) :
    copper-pour(LayerIndex(1, Top), isolate = 0.127, rank = 1) =  board-shape
    copper-pour(LayerIndex(3, Top), isolate = 0.127, rank = 1) =  board-shape
    copper-pour(LayerIndex(4, Top), isolate = 0.127, rank = 1) =  board-shape
  ; geom(P3V3) :
  ;   copper-pour(LayerIndex(2, Top), isolate = 0.127, rank = 1) =  board-shape
  ; geom(P1V8) :
  ;   copper-pour(LayerIndex(2, Top), isolate = 0.127, rank = 1) =  board-shape
  ; geom(P1V05) :
  ;   copper-pour(LayerIndex(2, Top), isolate = 0.127, rank = 1) =  board-shape

  geom(GND) :
    copper-pour(LayerIndex(1, Top), isolate = 0.127) =  board-shape
    copper-pour(LayerIndex(3, Top), isolate = 0.127) =  board-shape
    copper-pour(LayerIndex(4, Top), isolate = 0.127) =  board-shape


  inst asm2464pdx : ASM001/components/Asmedia/ASM2464PDX/module
  net (VBUS asm2464pdx.VBUS)
  net (P3V3 asm2464pdx.VCCH asm2464pdx.VCCA33)
  net (P1V8 asm2464pdx.VCCL)
  net (P1V05 asm2464pdx.VDD)

  place(asm2464pdx.sw) at loc(0.0, 0.0, 0.0) on Top

  inst usb4_type_c : ASM001/components/USB/USBTypeC/circuit

  net (usb4_type_c.VBUS VBUS)
  net (usb4_type_c.GND GND)

  place(usb4_type_c) at loc(-45.0, 15.0, 270.0) on Top

  inst W25Q32JVSSIQ : ASM001/components/Winbond/W25Q32JVSSIQ/module

  net (P3V3 W25Q32JVSSIQ.VDD)


  ;;;;; generic component types
  val r_4k7 = create-resistor(R-query, 
                              case = ["0201", "0402"], 
                              resistance = 4.7e3) ; 4.7K ohm
  val r_100K = create-resistor(R-query, 
                              case = ["0201", "0402"], 
                              resistance = 100.0e3) ; 100K ohm

  val r_12k1 = create-resistor(R-query, 
                              case = ["0201", "0402"], 
                              resistance = 12.1e3,
                              tolerance = 0.01) ; 12.1K ohm

  val c_1uF50V = create-capacitor(C-query, 
                                case = ["0201", "0402"], 
                                capacitance = 1.0e-6,
                                rated-voltage = 50.0) ; 1uF, 50V

  ;;;;; ASM2464PDX circuits 

  ;; ASM2464PDX bypass caps
  
  val c_22uF6V3 = create-capacitor(C-query, 
                              case = ["0201", "0402", "0805"],
                              capacitance = 22.0e-6,
                              rated-voltage = 6.3) ; 22uF, 6.3V
  
  val c_10uF6V3 = create-capacitor(C-query, 
                              case = ["0201", "0402", "0805"], 
                              capacitance = 10.0e-6,
                              rated-voltage = 6.3) ; 10uF, 6.3V

  val c_2u2F6V3 = create-capacitor(C-query, 
                              case = ["0201"], 
                              capacitance = 2.2e-6,
                              rated-voltage = 6.3) ; 2.2uF, 6.3V

  val c_0u22F6V3 = create-capacitor(C-query, 
                              case = ["0201"], 
                              capacitance = 0.22e-6,
                              rated-voltage = 10.0) ; 0.22uF, 10V 
  ; 1.05v
  ; 11 x 22UF/6.3V
  ; 3 x 10UF/6.3V
  ; 4 x 0.22UF/10v

  for i in 0 to 2 do :
    val n = to-string("c_22uF6V3-%_-C" % [i])
    ; val c = insert-capacitor(
    ;   asm2464pdx.VDD asm2464pdx.GND
    ;   c_22uF6V3
    ;   capacitance = 2.2e-6
    ;   short-trace? = true
    ; )
    val c = insert-bypass(asm2464pdx.sw.VDD[i], GND, inst-name = n, qb = CapacitorQuery(case = ["0201", "0402", "0805"],
                              capacitance = 22.0e-6,
                              rated-voltage = 6.3))
    place(c) at loc(2.0, 0.0, 90.0) on Bottom

  


  ; for v in pins(sw.VDD) do :
  ;   print(v.loc)
  ;   net (VDD v)

  ; 1.8v
  ; 3 x 10UF/6.3V
  ; 11 x 2.2UF/6.3V

  ;; ASM2464PDX SPI memory
  net (asm2464pdx.spi W25Q32JVSSIQ.spi)
  insert-pullup(W25Q32JVSSIQ.sw.SPI_IO2, asm2464pdx.VCCH,
                  elem-type = r_4k7,
                  inst-name? = to-string("spi_wp#-R"),
                  make-public = true)

  insert-pullup(W25Q32JVSSIQ.sw.SPI_IO3, asm2464pdx.VCCH,
                  elem-type = r_4k7,
                  inst-name? = to-string("spi_hold#-R"),
                  make-public = true)   

  ;; ASM2464PDX 25Mhz 18Pf crystal
  inst crystal_25mhz: ASM001/components/ABRACON/ABMM2-25_000MHZ-D1-T/component
  inst crystal_c : ASM001/components/KYOCERA-AVX/_04025A100FAT2A/component
  net (crystal_25mhz.GND0 GND)
  net (crystal_25mhz.GND1 GND)

  net (asm2464pdx.XI crystal_25mhz.p[1])
  net (asm2464pdx.XO crystal_25mhz.p[3])

  net (asm2464pdx.XI crystal_c.p[1])
  net (asm2464pdx.XO crystal_c.p[2])

  ; ASM2464PDX config straps

  insert-pullup(asm2464pdx.sw.UART_TX, asm2464pdx.VCCH,
                    elem-type = r_4k7,
                    inst-name? = to-string("uart_tx-R"),
                    make-public = true)

  ;; RST# RC pull-up
  insert-pullup(asm2464pdx.RST#, asm2464pdx.VCCH,
                    elem-type = r_100K,
                    inst-name? = to-string("r_100K"),
                    make-public = true)

  insert-pulldown(asm2464pdx.RST#, GND,
                    elem-type = c_1uF50V,
                    inst-name? = to-string("c_1uF50V"),
                    make-public = true)

  insert-pulldown(asm2464pdx.UREXT, GND,
                    elem-type = r_12k1,
                    inst-name? = to-string("UREXT-R"),
                    make-public = true)

  
  insert-pulldown(asm2464pdx.TEST_EN, GND,
                    elem-type = r_4k7,
                    inst-name? = to-string("TEST_EN-R"),
                    make-public = true)

  require asm2464pdx_usb-c : usb-c(2) from asm2464pdx

  net (usb4_type_c.VBUS asm2464pdx.VBUS)
  net (usb4_type_c.GND asm2464pdx.GND)

  net (usb4_type_c.USB-C.cc[0], asm2464pdx_usb-c.cc[0])
  net (usb4_type_c.USB-C.cc[1], asm2464pdx_usb-c.cc[1])

  net (usb4_type_c.USB-C.sbu[0], asm2464pdx_usb-c.sbu[0])
  net (usb4_type_c.USB-C.sbu[1], asm2464pdx_usb-c.sbu[1])
         





  public inst esd-prot : diodes/ESD224DQAR/device
  net (esd-prot.GND[1], esd-prot.GND[2], GND)

  ; Construct the topology from the module port, through
  ;  the ESD protector, and then terminating in the connector device.
  require esd-pair:dual-pair from esd-prot
  topo-pair(asm2464pdx_usb-c.data => esd-pair.A => esd-pair.B => usb4_type_c.USB-C.data)
  ; By setting the signal end - then the routing structure application
  ;   can apply to the entirety of the bus.
  ; set-signal-end(asm2464pdx_usb-c.data.P, usb4_type_c.USB-C.data.P)
  ; set-signal-end(asm2464pdx_usb-c.data.N, usb4_type_c.USB-C.data.N)
  
  ; According to USB4 System Design Guidelines
  val bleed-R = create-resistor(R-query, 
                              case = valid-smd-pkgs("0201"), 
                              resistance = Interval(200.0e3, 242.0e3) ; 220k ohm
                              )
  
  val rx-ac-C = create-capacitor(C-query, 
                                case = valid-smd-pkgs("0201"), 
                                capacitance = Interval(300.0e-9, 363.0e3)) ; 0.33uf

  val tx-ac-C = create-capacitor(C-query,
                                case = valid-smd-pkgs("0201"), 
                                capacitance = Interval(135.0e-9, 265.0e3)) ; 0.22uf

  ; val esd-lanes = diodes/ESD224DQAR/create-esd-pool(2, GND)

  ; USB-C CC pull-down resistors
  val cc-R = create-capacitor(C-query, capacitance = 2.2E-9, precision = (10 %), rated-voltage = 50.0) ; 220 pf / 50V
  for i in indices(asm2464pdx_usb-c.cc) do:
    val n = to-string("CC%_-R" % [i])
    insert-pulldown(asm2464pdx_usb-c.cc[i], GND,
                  elem-type = cc-R,
                  inst-name? = n,
                  make-public = true)

  for i in 0 to length(asm2464pdx_usb-c.lane) do:
    inst tx-bcap : dp-coupler(tx-ac-C)
    inst rx-bcap : dp-coupler(rx-ac-C)

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ESD
    val lane-esd-cap = ASM001/components/Infineon/ESD132-B1-W0201-E6327/component
    ; val usb4-esd-cap = create-part(mpn = "ESD132-B1-W0201 E6327", manufacturer = "Infineon")
    inst lane-esd-tx : dp-coupler(lane-esd-cap)
    inst lane-esd-rx : dp-coupler(lane-esd-cap)
    
    ; require tx-esd:dual-pair from esd-lanes
    topo-pair(usb4_type_c.USB-C.lane[i].TX => lane-esd-tx => tx-bcap => usb4_type_c.USB-C.lane[i].TX) ;tx-bcap => 

    ; require rx-esd:dual-pair from esd-lanes
    topo-pair(usb4_type_c.USB-C.lane[i].RX => lane-esd-rx => rx-bcap => usb4_type_c.USB-C.lane[i].RX) ;=> rx-bcap

    ; RX bleed resistors
    insert-pulldown(asm2464pdx_usb-c.lane[i].RX.P, GND, 
                    elem-type = bleed-R,
                    inst-name? = to-string("RX_P%_-R" % [i]), 
                    make-public = true)
    insert-pulldown(asm2464pdx_usb-c.lane[i].RX.N, GND,
                    elem-type = bleed-R,
                    inst-name? = to-string("RX_N%_-R" % [i]),
                    make-public = true)

    ; TX bleed resistors
    insert-pulldown(asm2464pdx_usb-c.lane[i].TX.P, GND,
                    elem-type = bleed-R,
                    inst-name? = to-string("TX_P%_-R" % [i]),
                    make-public = true)
    insert-pulldown(asm2464pdx_usb-c.lane[i].TX.N, GND,
                    elem-type = bleed-R,
                    inst-name? = to-string("TX_N%_-R" % [i]),
                    make-public = true)

    
  ; Shield Termination
  inst shield-term : shield-termination(R-query, C-query)
  net (shield-term.SHIELD, usb4_type_c.SHIELD)
  net (shield-term.GND, GND)

  val ti-2 = usb-get-trace-impedance(USB2)
  val usb2-constraints = USB-Constraint(proto = USB2, route-struct = diff(ti-2))
  constrain-topology(asm2464pdx_usb-c.data => usb4_type_c.USB-C.data, usb2-constraints)

  val b-cap = block-cap(100.0e-9)

  val ti-4 = usb-get-trace-impedance(USB4)
  val usb4-constraints = USB-Constraint(proto = USB4, route-struct = diff(ti-4))
  val lane-constraint = LaneConstraint(usb4-constraints)
  for i in indices(asm2464pdx_usb-c.lane) do :
    within [src, dst] = constrain-topology(asm2464pdx_usb-c.lane[i] => usb4_type_c.USB-C.lane[i], lane-constraint):
      ; Here we construct the differential pair topology for the lane.
      ; The Lane consists of two diff-pairs - TX and RX
      topo-pair(src.RX => dst.RX)

      ; The TX channel needs a blocking capacitor which we add with
      ;  the help of the `topo-pair` utility. This is like `topo-net`
      ;  but handles extracting the `dual-pair` require from the
      ;  `tx-bcap` for us.
      ; inst tx-bcap : dp-coupler(b-cap)
      topo-pair(src.TX => dst.TX)
    ; set-signal-end(asm2464pdx_usb-c.lane, usb4_type_c.USB-C.lane)
    
  ; inst header : ASM001/components/headers/header-test(2,1)
  ; place(header) at loc(-20.0, 15.0) on Top

  
 
  val m2_connectors = 1
  inst m2_connector : ASM001/components/TE_1-2199230-6/module[m2_connectors]
  place(m2_connector[0].sw) at loc(25.0, -10.0, 90.0) on Bottom

  val version = PCIE-V4
  val trace-imped = pcie-get-trace-impedance(version)
  val cst = PCIe-Constraint(version, diff(trace-imped))

  val pcie-b-cap = block-cap(220.0e-9)

  ; Construct a typical passive connector setup
  ;  for a 4x 1 lane configuration. This means a
  ;  straight through `tx => tx` and `rx => rx`
  ;  configuration.
  require src-ep : pcie(1) from asm2464pdx

  for i in 0 to m2_connectors :
    net (m2_connector[i].gnd GND)

    require dst-ep : pcie(1) from m2_connector[i]
   
    within [src, dst] = constrain-topology(src-ep, dst-ep, cst):
      ; Here we construct the circuit topology for the link
      ;   Note that we don't need to worry about any of the constraint
      ;   application, as that is handled by the `PCIe-Constraint` type.
      ;   You can add other components in the topology as you wish - below
      ;   is a typical basic implementation.
      for i in indices(src.data.lane) do:
        inst tx-coupler : dp-coupler(pcie-b-cap)
        topo-pair(src.data.lane[i].TX => tx-coupler => dst.data.lane[i].TX)
        ; No Blocking Caps on the Receive side.
        topo-pair(src.data.lane[i].RX => dst.data.lane[i].RX)

      topo-net(src.data.refclk => dst.data.refclk)
      ; The control signals do not demand a topology so
      ;  we just use a straight net connection.
      net (src.control, dst.control)
      

  ; schematic symbols
  symbol(GND) = GND-SYMB
  symbol(VBUS) = PWR-SYMB
  symbol(P3V3) = PWR-SYMB
  symbol(P1V8) = PWR-SYMB
  symbol(P1V05) = PWR-SYMB

; Set the :
;     design-name     - a directory with this name will be created in the "designs" directory
;     board           - a Board object representing the stackup, rules and board shape for a particular design
;     signal-shrink   - a distance in mm to pull back copper signals from the board edge
setup-design("ASM001-design", board-shape, signal-shrink = 0.5)

; Set the top level module (the module to be compile into a schematic and PCB)
set-main-module(ASM001-design)

; View the results
; take a look at the BOM that was generated
view-bom(BOM-STD)
; examine the schematic that was auto-generated
view-schematic()
; view the board that was created
view-board()


