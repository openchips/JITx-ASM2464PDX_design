; Generated by JITX 3.25.0
#use-added-syntax(jitx)
defpackage main :
  import core
  import jitx
  import jitx/commands
  import jitx/parts

  import jsl
  import helpers
  import jsl/bundles

  import jsl/landpatterns/headers
  import jsl/protocols/usb
  import jsl/si/constraints
  import jsl/si/pairs
  import jsl/si/helpers
  import jsl/si/couplers
  import jsl/symbols/net-symbols


  import board
  import ASM001/common/components
  import ASM001/components/TE_2388749-1 ; Import the package containing the definition

  import TI-vreg/components/TPS6293x

; Define the shape/size of the board
val board-shape = RoundedRectangle(100.0, 50.0, 0.25)

; Module to run as a design
pcb-module ASM001-design :
  ; define some pins/ports
  port gnd
  port vbus

  net GND (gnd)
  net VBUS (vbus)

  val R-query = get-default-resistor-query()
  val C-query = get-default-capacitor-query()

  ; ; 1.05v reg 2a/3a/4a
  val cxt-1v05 = power-systems/DC-DC/buck/BuckConstraints(
  v-in = min-max(4.9, 5.1)
  v-out = 1.05 +/- (3 %)
  v-in-ripple-max = 0.3
  v-out-ripple-max = 0.030
  i-out = 2.0 +/- (20 %)
  freq = 1.2e6
  K = (40 %)
  )

  inst DCDC-1v05 : TI-vreg/components/TPS6293x/circuit(
  TI-vreg/components/TPS6293x/TPS62932DRL
  cxt-1v05
  C-query? = C-query
  )

  ; 3.3v buck regulator 4a
  val cxt-3v3 = power-systems/DC-DC/buck/BuckConstraints(
  v-in = min-max(4.9, 5.1)
  v-out = 3.3 +/- (3 %)
  v-in-ripple-max = 0.6
  v-out-ripple-max = 0.33
  i-out = 3.0 +/- (30 %)
  freq = 2.2e6
  K = (40 %)
  )

  inst DCDC-3v3 : TI-vreg/components/TPS6293x/circuit(
  TI-vreg/components/TPS6293x/TPS62932DRL
  cxt-3v3
  C-query? = C-query
  )

  ; 1.8v reg 2a/3a/4a
  val cxt-1v8 = power-systems/DC-DC/buck/BuckConstraints(
  v-in = min-max(4.9, 5.1)
  v-out = 1.8 +/- (3 %)
  v-in-ripple-max = 0.050
  v-out-ripple-max = 0.030
  i-out = 2.0 +/- (20 %)
  freq = 1.2e6
  K = (40 %)
  )

  inst DCDC-1v8 : TI-vreg/components/TPS6293x/circuit(
  TI-vreg/components/TPS6293x/TPS62932DRL
  cxt-1v8
  C-query? = C-query
  )


  ; 3.3v LDO 500mA

  ; inst W25Q32JVSSIQ : database-part(["manufacturer" => "Winbond", "mpn" => "W25Q32JVSSIQ"])
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             
  inst usb4_type_c : ASM001/components/USB/USBTypeC/conn-component


  inst asm2464pdx : ASM001/components/Asmedia/ASM2464PDX/module
  ; inst usb4_type_c : ASM001/components/TE_2388749-1/module

  ; inst usb4_type_c : USBC-USB4-Iface()

  require asm2464pdx_usb-c : usb-c(2) from asm2464pdx
  require connector_usb-c : usb-c-connector from usb4_type_c

  ; net (usb4_type_c.VBUS[0], usb4_type_c.VBUS[1], usb4_type_c.VBUS[2], usb4_type_c.VBUS[3], VBUS)

  net (connector_usb-c.vbus.V+, VBUS)
  net (connector_usb-c.vbus.V-, GND)

  net (connector_usb-c.bus.cc[0], asm2464pdx_usb-c.cc[0])
  net (connector_usb-c.bus.cc[1], asm2464pdx_usb-c.cc[1])

  public inst esd-prot : diodes/ESD224DQAR/device
  net (esd-prot.GND[1], esd-prot.GND[2], GND)

  ; Construct the topology from the module port, through
  ;  the ESD protector, and then terminating in the connector device.
  require esd-pair:dual-pair from esd-prot
  topo-pair(asm2464pdx_usb-c.data => esd-pair.A => esd-pair.B => connector_usb-c.bus.data)
  ; By setting the signal end - then the routing structure application
  ;   can apply to the entirety of the bus.
  ; set-signal-end(asm2464pdx_usb-c.data, connector_usb-c.bus.data)

  
  ; According to USB4 System Design Guidelines
  val bleed-R = create-resistor(R-query, 
                              case = valid-smd-pkgs("0201"), 
                              resistance = Interval(200.0e3, 242.0e3)
                              )
  
  val rx-ac-C = create-capacitor(C-query, 
                                case = valid-smd-pkgs("0201"), 
                                capacitance = Interval(300.0e-9, 363.0e3))

  val tx-ac-C = create-capacitor(C-query,
                                case = valid-smd-pkgs("0201"), 
                                capacitance = Interval(135.0e-9, 265.0e3))

  ; val esd-lanes = diodes/ESD224DQAR/create-esd-pool(2, GND)

  for i in 0 to length(asm2464pdx_usb-c.lane) do:
    inst tx-bcap : dp-coupler(tx-ac-C)
    inst rx-bcap : dp-coupler(rx-ac-C)

    ; require tx-esd:dual-pair from esd-lanes
    topo-pair(asm2464pdx_usb-c.lane[i].TX => tx-bcap => connector_usb-c.bus.lane[i].TX)

    ; require rx-esd:dual-pair from esd-lanes
    topo-pair(asm2464pdx_usb-c.lane[i].RX => rx-bcap => connector_usb-c.bus.lane[i].RX)

  ; Shield Termination
  inst shield-term : shield-termination(R-query, C-query)
  net (shield-term.SHIELD, connector_usb-c.shield)
  net (shield-term.GND, GND)

  val ti-2 = usb-get-trace-impedance(USB2)
  val usb2-constraints = USB-Constraint(proto = USB2, route-struct = diff(ti-2))
  constrain-topology(asm2464pdx_usb-c.data => connector_usb-c.bus.data, usb2-constraints)

  val b-cap = block-cap(100.0e-9)

  val ti-4 = usb-get-trace-impedance(USB4)
  val usb4-constraints = USB-Constraint(proto = USB4, route-struct = diff(ti-4))
  val lane-constraint = LaneConstraint(usb4-constraints)
  for i in indices(asm2464pdx_usb-c.lane) do :
    within [src, dst] = constrain-topology(asm2464pdx_usb-c.lane[i] => connector_usb-c.bus.lane[i], lane-constraint):
      ; Here we construct the differential pair topology for the lane.
      ; The Lane consists of two diff-pairs - TX and RX
      topo-pair(src.RX => dst.RX)

      ; The TX channel needs a blocking capacitor which we add with
      ;  the help of the `topo-pair` utility. This is like `topo-net`
      ;  but handles extracting the `dual-pair` require from the
      ;  `tx-bcap` for us.
      ; inst tx-bcap : dp-coupler(b-cap)
      topo-pair(src.TX => dst.TX)

  ; ; inst header : Header(
  ; ;   pitch = 0.254, 
  ; ;   num-leads = 2, 
  ; ;   rows = 1,
  ; ;   package-body = PackageBody(height = 1.0 +/- (20 %), length = 0.508 +/- (20 %)),
  ; ;   pad-diam = 2.54,
  ; ;   lead-type = TH-Lead(length = 0.2, width = 0.2))

  ; place(header) at loc(-20.0, 15.0) on Top

  
  val version = PCIE-V4
  val trace-imped = pcie-get-trace-impedance(version)
  val cst = PCIe-Constraint(version, diff(trace-imped))

  val pcie-b-cap = block-cap(220.0e-9)

  ; Construct a typical passive connector setup
  ;  for a 4 lane configuration. This means a
  ;  straight through `tx => tx` and `rx => rx`
  ;  configuration.

  inst m2_connector : ASM001/components/TE_1-2199230-6/module


  require src-ep : pcie(4) from asm2464pdx
  require dst-ep : pcie(4) from m2_connector

  within [src, dst] = constrain-topology(src-ep, dst-ep, cst):
    ; Here we construct the circuit topology for the link
    ;   Note that we don't need to worry about any of the constraint
    ;   application, as that is handled by the `PCIe-Constraint` type.
    ;   You can add other components in the topology as you wish - below
    ;   is a typical basic implementation.
    for i in indices(src.data.lane) do:
      inst tx-coupler : dp-coupler(pcie-b-cap)
      topo-pair(src.data.lane[i].TX => tx-coupler => dst.data.lane[i].TX)
      ; No Blocking Caps on the Receive side.
      topo-net(src.data.lane[i].RX => dst.data.lane[i].RX)

    topo-net(src.data.refclk => dst.data.refclk)
    ; The control signals do not demand a topology so
    ;  we just use a straight net connection.
    net (src.control, dst.control)


  ; schematic symbols
  symbol(GND) = GND-SYMB
  symbol(VBUS) = PWR-SYMB

; Set the :
;     design-name     - a directory with this name will be created in the "designs" directory
;     board           - a Board object representing the stackup, rules and board shape for a particular design
;     signal-shrink   - a distance in mm to pull back copper signals from the board edge
setup-design("ASM001-design", board-shape, signal-shrink = 0.5)

; Set the top level module (the module to be compile into a schematic and PCB)
set-main-module(ASM001-design)

; View the results
; take a look at the BOM that was generated
view-bom(BOM-STD)
; examine the schematic that was auto-generated
view-schematic()
; view the board that was created
view-board()


